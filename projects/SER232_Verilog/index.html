<html>

<head>

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>

<script   src="https://code.jquery.com/jquery-2.2.2.min.js"   integrity="sha256-36cp2Co+/62rEAAYHLmRCPIych47CvdM+uTBJwSzWjI="   crossorigin="anonymous"></script>

<link href="myStyles.css" rel="stylesheet">
<script src="functionality.js"></script>

   <title>SER 232 Verilog</title>
</head>

<body>
<div class="container">
   <div class="js-navigationBar">
      <nav class="navbar navbar-default navbar-fixed-top nav-justified" role="navigation">
         <div class="container-fluid">
            <div class="navbar-header"> <!-- Start of collapsed navbar -->
               <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar" aria-expanded="false">
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
               </button> 
            </div> <!-- End of collapsed navbar -->
            <div class="collapse navbar-collapse" id="myNavbar"> <!-- Start un-collapsed navbar -->
               <ul class="nav navbar-nav navbar-left">
                  <li class="my-js-navigationTab active" id="my-js-informationTab-Verilog"><a href="#myVerilog" rel="" id="anchorVerilog" class="anchorLink my-js-smoothScrolling">Project 3</a></li>
                  <li class="my-js-navigationTab" id="my-js-informationTab-XX"><a href="#myXX" rel="" id="anchorXX" class="anchorLink my-js-smoothScrolling"></a></li>
               </ul>
            </div> <!-- End un-collapsed navbar -->
         </div>
      </nav>
   </div>   
   <div id="content">
      <h1> SER232 Project 3: Calculator </h1>

<p>
Build a Verilog module named "calculator" that takes in two signed 16-bit numbers named "in1" and "in2" and performs the following functions depending on the value of another 4-bit input named "opCode" (see table below). Be aware that the opCode is not signed like the inputs A and B of project 2 were. The outputs of the module "calculator" must be a signed 16-bit number named "result", and a 1-bit "overflow". Be aware that the value of "overflow" doesn't always get calculated the same way, it depends on the operation (see table below for more info and examples). The value of the output "overflow" will be one if an overflow occurred or the value of "result" is not completely accurate or correct; else the output "overflow" will be zero. 
</p>
<p>
Name the new project you create Project3_FirstName_LastName, using your own name. For instance, I would name my project "Project3_Yoalli_Hidalgo". Once you are done with the code, submit the whole project folder compressed (as .zip, .rar, or .7z), which must contain all the files Xilinx ISE generated and of course make sure it contains the Verilog source code files (implementation and your own test bench, both with extension .v).
</p>
<p>
The syntax to declare buses as signed is: <br />
<span class="css-code">
   input signed [15:0] in1;<br />
   output reg signed [15:0] result; <br />
                   //Declaring outputs as "reg" will allow you to assign values to them<br />
</span>
</p> 
<p>
Also, be aware that unsigned N-bit registers can store values from 0 to 2N-1. While signed N-bit registers can store values from -2N-1 to 2N-1-1.     
</p>
<table style="width:100%">
  <tr>
    <td>opCode  </td> 
    <td>Operation that has to be performed</td>
  </tr>
  <tr>
    <td>0000</td> 
    <td>Add both inputs. Be aware that the overflow detection when adding and subtracting must be different than for Project 2 because in Project 2 the inputs were unsigned, while now for Project 3 the inputs are signed.</td>
  </tr>
  <tr>
    <td>0001</td> 
    <td>Subtract in1 - in2.</td>
  </tr>
  <tr>
    <td>0010</td> 
    <td>Multiply in1 by five</td>
  </tr>
  <tr>
    <td>0011</td> 
    <td>Divide in1 by ten. When dividing by ten, signal an overflow when in1 is not exactly divisible by ten. For instance, if in1=30, then result=3 and overflow=0; but if in1=35, then result=3 and overflow=1. You will need to explore the use of the percentage sign (%), which performs modulo operations (also known as "modulus operator", https://en.wikipedia.org/wiki/Modulo_operation ). The modulo finds the remainder of a division. If the remainder is zero then overflow=0; but if the remainder is not zero then produce overflow =1.</td>
  </tr>
  <tr>
    <td>0100</td> 
    <td>Bitwise AND. Even though in1, in2 and result are declared as signed numbers, when applying the bitwise operations they are taken as raw bits. A bitwise operation (https://en.wikipedia.org/wiki/Bitwise_operation ) is when the operation is applied to the individual bits. In this case, there will be an AND gate operation between the individual bits of in1 and the individual bits of in2; such that an AND logic will be applied to the first bit of in1 and the first bit of in2 and the output of that AND will be the first bit of result; an AND logic will be applied to the bit of position n of in1 and the bit of position n of in2 and the output of that AND will be the bit of position n of result; and so on. For example:</br>
in1 = 1010110011110000</br>
in2 = 1100101000110011</br>
result = 1000100000110000</br>
Bitwise AND, XOR and OR operations can't overflow, so overflow=0 by default.
0101	Bitwise XOR. Similar to explanation above, but with an XOR (also known as exclusive OR) operation instead. Example:</br>
    in1 = 1010110011110000</br>
    in2 = 1100101000110011</br>    
result = 0110011011000011</br>
</td>
  </tr>
  <tr>
    <td>0110</td> 
    <td>Bitwise OR. Similar to explanation above, but with an XOR operation instead. Example:
in1 = 1010110011110000
in2 = 1100101000110011     
result = 1110111011110011
</td>
  </tr>
  <tr>
    <td>0111</td> 
    <td>One's Complement in1. Perform one's complement, by inverting bits (do not add one afterwards, because that would be two's complement). 
Complement operation can't overflow, so overflow=0 by default.
Examples: 
in1='b00000000000000; opCode='b0111; expectedOverflow='b0; result='b1111111111111111;

in1='b0000000000000001; opCode='b0111; expectedOverflow='b0; result='b1111111111111110; 
</td>
  </tr>
  <tr>
    <td>1000</td> 
    <td>Increment in1 by 1. Examples: if in1=3, then result =4. If in1=-3, then result =-2.</td>
  </tr>
  <tr>
    <td>1001</td> 
    <td>Decrement in1 by 1. Examples: if in1=3, then result =2. If in1=-3, then result =-4.</td>
  </tr>
  <tr>
    <td></td> 
    <td></td>
  </tr>
</table>


<h2>Your test bench: </h2>

<p>
Your test bench must show a good effort in testing. You must test all the opCodes. Test when in1 is positive and when it is negative, and when in2 is positive and when it is negative. Test values that produce overflow, and also values that don't produce overflow. Also, pay attention to interesting values, like border (or corner) cases, like: 32767, 32766, 1, 0, -1, -32767, -32768. 
</p>    
<p> 
There must be minimum 23 test cases covering these scenarios:
<ul>
   <li>one test per bitwise operation,</li>
   <li>two test cases (one not producing overflow and another producing overflow) for each of the operations of: 
   <ul>
      <li>increment,</li>
      <li>decrement</li>
      <li>divide </li>
   </ul>
   <li>four test cases for multiplication:
   <ul>
      <li>one not producing overflow when in1 is positive</li>
      <li>one not producing overflow when in1 is negative,</li>
      <li>one producing overflow when the result is too positive</li>
      <li>one producing overflow when the result is too negative</li>
   </ul>
   </li>
   <li>six test cases for addition: 
   <ul>
      <li>two test cases that produce overflow: 
      <ul>
         <li>one producing overflow when the result is too positive</li>
         <li>one producing overflow when the result is too negative</li>
      </ul></li>
      <li>four test cases that don't produce overflow:
      <ul>
         <li>one where in1 is positive and in2 is positive</li>
         <li>one where in1 is positive and in2 is negative</li>
         <li>one where in1 is negative and in2 is positive</li>
         <li>one where in1 is negative and in2 is negative</li>
      </ul>
      </li>
   </ul>
   </li>
   <li>six test cases for subtraction:
   <ul>
      <li>two test cases that produce overflow: 
      <ul>
         <li>one producing overflow when the result is too positive</li>
         <li>one producing overflow when the result is too negative</li>
      </ul>
      </li>
      <li>four test cases that don't produce overflow:
      <ul>
         <li>one where in1 is positive and in2 is positive</li>
         <li>one where in1 is positive and in2 is negative</li>
         <li>one where in1 is negative and in2 is positive</li>
         <li>one where in1 is negative and in2 is negative</li>
      </ul>
      </li>
   </ul>
   </li>
</ul>
</p>
<p>
Include in your test bench a $monitor statement in order to keep track and print in console changes in the inputs and outputs. Alternatively you could have $display statements instead. For example: 
</p>
<span class="css-code">
$monitor("opCode( %b ), in1( %d ), in2( %d ), result( %d ), overflow( %b )",  opCode, in1, in2, result, overflow); 
</span>


<h2>Instructor's test bench: </h2>
<p>
The intended process is that you would code your implementation, then you would create your own test bench and use it to make sure your implementation was correct to the best of your knowledge. Then you would use the instructor's test bench to ensure you actually implemented it and tested it correctly. 
</p>
<p>
I want you to form the habit of testing your own code because it is an important self-discipline habit that improves the quality of your work. When you graduate and are out there producing code, documentation, scripts, etc. your teammates and boss will value you based on the quality of your work. They will have a much better image of you (and you will get promotions and rises, and put you in charge of more important things) if they can rarely find faults in what you produce than if they always find errors. Please make a commitment to quality. 
</p>
<p>
Make sure the simulation runs for at least 145000 ns to ensure it lasts enough time to run all test cases inside "quot;Proejct3_TestBench_byInstructor.v"quot;. If you don't remember how to make the simulation to run longer than the default time, check the instructions document of project 2. Make sure not to copy any line of code from my test bench into your own test bench, because that is plagiarism. 
</p>
<p>
There are a total of 1440 test cases in the instructor's test bench. As they run, they are classified as correct or incorrect depending on if your calculator's outputs are equal or not to the expected outputs. After all of them have been run, the number of correct and incorrect test cases get printed in the console (if you don't see this text printed is because the simulation is not running long enough). You have to debug your calculator implementation based on the data provided by those incorrect test cases such that you reach 0 incorrect test cases and 1440 correct test cases.
</p>

     
   </div>
</div>


</body>
</html>